<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mobile Orderflow — Balanced Institutional Dashboard (Deep Walls)</title>
<!-- =========================
     STYLES — Improved UI
     Part 1 of 3
     ========================= -->
<style>
:root{
  --bg:#071226;
  --card:#0f2030;
  --muted:#9fb0c8;
  --accent:#00d084;
  --buy:#66ffb2;
  --sell:#ff7b7b;
  --text:#e6f0fb;
  --border:#152433;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:var(--bg);color:var(--text);-webkit-font-smoothing:antialiased}
.wrap{max-width:1180px;margin:12px auto;padding:14px}
/* Header */
.header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
.title{font-size:20px;margin:0 0 2px 0;font-weight:600}
.subtitle{font-size:13px;color:var(--muted)}
/* Controls */
.controls{display:flex;gap:8px;align-items:center}
select,input,button{padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:#071b2b;color:var(--text);font-size:13px}
select{min-width:180px}
button{cursor:pointer}
/* Layout */
.card{background:var(--card);padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.45);margin-top:12px;border:1px solid var(--border)}
.row{display:flex;justify-content:space-between;align-items:center}
.muted{color:var(--muted);font-size:13px}
.grid{display:grid;grid-template-columns:1fr 400px;gap:16px;margin-top:12px;align-items:start}
@media (max-width:920px){ .grid{grid-template-columns:1fr;gap:12px} .header{flex-direction:column;align-items:flex-start} }
/* trade list */
.trade-list{height:260px;overflow:auto;padding:6px;margin-top:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
.trade{display:flex;justify-content:space-between;padding:6px;border-radius:6px;margin-bottom:4px;font-size:13px}
.buy{color:var(--buy)} .sell{color:var(--sell)}
.small{font-size:12px;color:var(--muted)}
/* panels and misc */
.table{font-size:13px;line-height:1.45}
.badge{display:inline-block;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}
.alertBox{padding:12px;border-radius:10px;margin-bottom:10px}
.swing-high{background:rgba(255,90,90,0.10);border:1px solid rgba(255,90,90,0.25);color:#ffb3b3}
.swing-low{background:rgba(0,210,130,0.10);border:1px solid rgba(0,210,130,0.28);color:#baffdf}
#swingPanelContainer{max-height:260px;overflow-y:auto;margin-bottom:6px}
/* Deep walls radar */
.radar{
  display:flex;
  gap:10px;
  flex-direction:column;
  margin-top:10px;
}
.radar .row{align-items:flex-start}
.radar .col{flex:1;min-height:160px;max-height:360px;overflow:auto;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid var(--border)}
.radar h4{margin:0 0 6px 0;font-size:14px}
/* L2 walls */
.l2-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:8px}
.l2-grid .table{max-height:280px;overflow:auto;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01)}
/* utility */
.center{display:flex;align-items:center;justify-content:center}
.hidden{display:none}
/* swing rating stars formatting */
.stars{font-family: "Segoe UI Symbol", "Noto Color Emoji", "Apple Color Emoji", sans-serif;letter-spacing:2px}
.big{font-size:18px;font-weight:600;margin-top:4px}
.small-input{font-size:12px;padding:6px 8px}
.footer-note{opacity:0.7;font-size:11px}
.signal-yes{color:#00ff88;font-weight:600}
.signal-no{color:#9fb0c8;font-weight:600}
</style>
</head>
<body>
<div class="wrap">
  <!-- HEADER -->
  <div class="header">
    <div>
      <h1 class="title">Orderflow Analyst — Balanced (Mobile)</h1>
      <div class="subtitle">Option C — Microstructure swing (sweep + delta flip) + Deep Wall Radar</div>
      <div style="margin-top:8px;display:flex;align-items:center;gap:12px">
        <div class="small muted">Current Price:</div>
        <div id="currentPrice" style="font-size:20px;font-weight:600;color:var(--accent)">—</div>
        <div id="priceChange" style="font-size:14px;font-weight:500">—</div>
      </div>
    </div>
    <div class="controls">
      <label class="small muted">Symbol</label>
      <select id="symbol"></select>
      <label class="small muted">Mode</label>
      <select id="modeSelect" title="Data mode">
        <option value="ws">WS only (fast)</option>
        <option value="rest">REST deep (snapshot)</option>
        <option value="both" selected>Both (recommended)</option>
      </select>
      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" style="display:none">Disconnect</button>
      <span id="status" class="small muted">Disconnected</span>
    </div>
  </div>
  <!-- TOP STATS -->
  <div class="card">
    <div class="row">
      <div style="flex:1">
        <div id="swingPanelContainer"></div>
        <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:8px">
          <div>
            <div class="small muted">Calibration</div>
            <div id="calib" class="small">Not running</div>
          </div>
          <div>
            <div class="small muted">Cumulative Delta</div>
            <div id="cumlDelta">0</div>
          </div>
          <div>
            <div class="small muted">Buy / Sell Vol</div>
            <div id="vols">0 / 0</div>
          </div>
          <div>
            <div class="small muted">Strength</div>
            <div id="strength">—</div>
          </div>
        </div>
      </div>
      <div style="width:260px;text-align:right">
        <div class="small muted">Tune</div>
        <div style="display:flex;gap:8px;align-items:center;justify-content:flex-end;margin-top:8px">
          <label class="small muted">WallSize</label>
          <input id="wallSize" class="small-input" value="50" style="width:70px"/>
          <label class="small muted">Burst</label>
          <input id="burstCnt" class="small-input" value="8" style="width:70px"/>
        </div>
      </div>
    </div>
  </div>
  <!-- GRID -->
  <div class="grid">
    <!-- LEFT COLUMN -->
    <div>
      <div class="card">
        <div class="small muted">Sweep Status</div>
        <div id="sweepInfo" style="margin-top:8px">Sweep: —</div>
      </div>
      <div class="card">
        <div class="small muted">Logs</div>
        <div id="logs" style="max-height:200px;overflow:auto;margin-top:8px" class="small"></div>
      </div>
    </div>
    <!-- RIGHT COLUMN -->
    <div>
      <div class="card">
        <div class="small muted">5 Key Signals (Live)</div>
        <div style="margin-top:8px;font-size:13px">
          <div style="display:flex;justify-content:space-between;margin-bottom:6px">
            <span>Liquidity Sweep:</span>
            <span id="signalSweep" style="font-weight:600">NO</span>
          </div>
          <div style="display:flex;justify-content:space-between;margin-bottom:6px">
            <span>Delta Flip:</span>
            <span id="signalDeltaFlip" style="font-weight:600">NO</span>
          </div>
          <div style="display:flex;justify-content:space-between;margin-bottom:6px">
            <span>Momentum:</span>
            <span id="signalMomentum" style="font-weight:600">NO</span>
          </div>
          <div style="display:flex;justify-content:space-between;margin-bottom:6px">
            <span>Wall Shift:</span>
            <span id="signalWallShift" style="font-weight:600">NO</span>
          </div>
          <div style="display:flex;justify-content:space-between">
            <span>Reaction Speed:</span>
            <span id="signalReaction" style="font-weight:600">NO</span>
          </div>
        </div>
      </div>
      <div class="card">
        <div class="small muted">Quick Indicators</div>
        <div style="margin-top:8px;font-size:13px">
          <div style="display:flex;justify-content:space-between;margin-bottom:6px">
            <span>Liquidity Sweep:</span>
            <span id="indicatorLiquiditySweep" style="font-weight:600">NO</span>
          </div>
          <div style="display:flex;justify-content:space-between;margin-bottom:6px">
            <span>Delta Flip:</span>
            <span id="indicatorDeltaFlip" style="font-weight:600">NO</span>
          </div>
          <div style="display:flex;justify-content:space-between">
            <span>Reaction:</span>
            <span id="indicatorReaction" style="font-weight:600">NO</span>
          </div>
        </div>
      </div>
      <div class="card">
        <div class="small muted">Wall Clusters Analysis</div>
        <div style="margin-top:8px">
          <div style="display:flex;justify-content:space-between;margin-bottom:8px">
            <span class="small muted">Buy clusters:</span>
            <span id="buyCluster" style="font-weight:600">0</span>
          </div>
          <div style="display:flex;justify-content:space-between;margin-bottom:8px">
            <span class="small muted">Sell clusters:</span>
            <span id="sellCluster" style="font-weight:600">0</span>
          </div>
          <div style="display:flex;justify-content:space-between;margin-bottom:8px">
            <span class="small muted">Total Buy Wall Qty:</span>
            <span id="totalBuyWallQty" style="font-weight:600">0</span>
          </div>
          <div style="display:flex;justify-content:space-between;margin-bottom:8px">
            <span class="small muted">Total Sell Wall Qty:</span>
            <span id="totalSellWallQty" style="font-weight:600">0</span>
          </div>
          <div style="display:flex;justify-content:space-between;margin-bottom:8px">
            <span class="small muted">Largest Buy Wall:</span>
            <span id="largestBuyWall" style="font-weight:600">—</span>
          </div>
          <div style="display:flex;justify-content:space-between;margin-bottom:10px">
            <span class="small muted">Largest Sell Wall:</span>
            <span id="largestSellWall" style="font-weight:600">—</span>
          </div>
          <div style="margin-top:10px;border-top:1px solid var(--border);padding-top:8px">
            <div class="small muted" style="margin-bottom:6px">Top 12 Buy Walls (Price — Qty)</div>
            <div id="topBids" class="table" style="max-height:180px;overflow:auto;font-size:12px"></div>
          </div>
          <div style="margin-top:10px;border-top:1px solid var(--border);padding-top:8px">
            <div class="small muted" style="margin-bottom:6px">Top 12 Sell Walls (Price — Qty)</div>
            <div id="topAsks" class="table" style="max-height:180px;overflow:auto;font-size:12px"></div>
          </div>
        </div>
      </div>
      <div class="card">
        <div class="small muted">Controls</div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="clearBtn">Clear State</button>
          <button id="downloadBtn">Download L2 CSV</button>
        </div>
        <div class="small muted footer-note" style="margin-top:8px">Auto reconnect enabled. Using WS + REST deep snapshots.</div>
      </div>
    </div>
  </div>
  <!-- DEEP WALL RADAR (NEW) -->
  <div class="card">
    <div class="small muted">Deep Liquidity Radar (Far Walls)</div>
    <div class="radar" style="margin-top:10px">
      <div class="row">
        <div style="flex:1">
          <h4>5 Large Buys (below price, nearest first)</h4>
          <div id="farBuys" class="col table">—</div>
        </div>
        <div style="width:18px"></div>
        <div style="flex:1">
          <h4>5 Large Sells (above price, nearest first)</h4>
          <div id="farSells" class="col table">—</div>
        </div>
      </div>
      <div style="display:flex;gap:10px;margin-top:10px;align-items:center">
        <label class="small muted">Distance filter (%)</label>
        <input id="radarDistPct" value="2" style="width:70px" />
        <label class="small muted">Min wall qty (native)</label>
        <input id="radarMinQty" value="50" style="width:80px" />
        <div class="small muted">Mode: deep REST snapshot (depth1000) + WS top20</div>
      </div>
    </div>
  </div>
  <!-- L2 walls bottom -->
  <div class="card">
    <div class="small muted">L2 Order Book Depth (depth20)</div>
    <div style="display:flex;gap:12px;margin-top:8px;margin-bottom:8px;flex-wrap:wrap">
      <div style="flex:1;min-width:120px">
        <div class="small muted">Best Bid: <span id="bestBid" style="font-weight:600">-</span></div>
        <div class="small muted">Best Ask: <span id="bestAsk" style="font-weight:600">-</span></div>
        <div class="small muted">Spread: <span id="spread" style="font-weight:600">-</span></div>
      </div>
      <div style="flex:1;min-width:120px">
        <div class="small muted">Bid Levels: <span id="bidLevels" style="font-weight:600">0</span></div>
        <div class="small muted">Ask Levels: <span id="askLevels" style="font-weight:600">0</span></div>
        <div class="small muted">Mid Price: <span id="midPrice" style="font-weight:600">-</span></div>
      </div>
    </div>
    <div class="l2-grid" style="margin-top:8px">
      <div>
        <div class="small muted" style="margin-bottom:6px">BIDS (Price — Qty — % from Mid)</div>
        <div id="buyWalls" class="table" style="max-height:320px;overflow:auto;margin-top:6px;font-size:12px"></div>
      </div>
      <div>
        <div class="small muted" style="margin-bottom:6px">ASKS (Price — Qty — % from Mid)</div>
        <div id="sellWalls" class="table" style="max-height:320px;overflow:auto;margin-top:6px;font-size:12px"></div>
      </div>
    </div>
  </div>
</div> <!-- wrap -->

<!-- ============================
     Part 2/3 — Core JS Engine
     - Symbol loader
     - WS connect / messages
     - Trade & depth handlers
     - Aggregation (1m / 5m) with price
     - Divergence detection
     - Swing engine & stars
     - UI updates + controls
     ============================ -->
<script>
/* ---------- CONFIG ---------- */
const CALIBRATION_SECONDS = 180;
const WALL_SIZE_DEFAULT = 50;
const BURST_WINDOW_MS = 2500;
const MAX_TRADES_DISPLAY = 200;
const AGG_MAX = 200;

/* ---------- STATE ---------- */
let ws = null;
let running = false;
let symbol = null;
let useMode = 'both'; // 'ws' | 'rest' | 'both'
let buyVol = 0, sellVol = 0, cumDelta = 0;
let recentTrades = []; // {price, qty, side, ts}
let bids = [], asks = [];
let lastPrice = null, lastPrice2 = null;
let lastHigh = null, lastLow = null;
let lastDeltaSide = null;
let lastOrderbookSnapshot = null;
let agg1m = []; // {tStart, buyVol, sellVol, delta, price}
let agg5m = []; // same structure

/* ---------- Current Signal State ---------- */
let currentSignals = {
  sweep: 'NO',
  deltaFlip: 'NO',
  momentum: 'NO',
  wallShift: 'NO',
  reaction: 'NO',
  sweepLow: 'NO',
  reactionSpeed: 'NO'
};

/* ---------- UI refs ---------- */
const symbolSelect = document.getElementById('symbol');
const modeSelect = document.getElementById('modeSelect');
const connectBtn = document.getElementById('connectBtn');
const disconnectBtn = document.getElementById('disconnectBtn');
const statusEl = document.getElementById('status');
const logsEl = document.getElementById('logs');
const buyWallsEl = document.getElementById('buyWalls');
const sellWallsEl = document.getElementById('sellWalls');
const topBidsEl = document.getElementById('topBids');
const topAsksEl = document.getElementById('topAsks');
const buyClusterEl = document.getElementById('buyCluster');
const sellClusterEl = document.getElementById('sellCluster');
const volsEl = document.getElementById('vols');
const cumlEl = document.getElementById('cumlDelta');
const strengthEl = document.getElementById('strength');
const sweepInfoEl = document.getElementById('sweepInfo');
const swingPanelContainer = document.getElementById('swingPanelContainer');
const wallSizeInput = document.getElementById('wallSize');
const clearBtn = document.getElementById('clearBtn');
const downloadBtn = document.getElementById('downloadBtn');
const calibEl = document.getElementById('calib');
/* Signal display refs */
const signalSweepEl = document.getElementById('signalSweep');
const signalDeltaFlipEl = document.getElementById('signalDeltaFlip');
const signalMomentumEl = document.getElementById('signalMomentum');
const signalWallShiftEl = document.getElementById('signalWallShift');
const signalReactionEl = document.getElementById('signalReaction');
const indicatorLiquiditySweepEl = document.getElementById('indicatorLiquiditySweep');
const indicatorDeltaFlipEl = document.getElementById('indicatorDeltaFlip');
const indicatorReactionEl = document.getElementById('indicatorReaction');
const currentPriceEl = document.getElementById('currentPrice');
const priceChangeEl = document.getElementById('priceChange');

/* ---------- UTIL ---------- */
const f = v => (v === undefined || v === null) ? 0 : parseFloat(v);
const now = () => Date.now();
function log(msg){
  const d = document.createElement('div');
  d.innerText = `[${(new Date()).toLocaleTimeString()}] ${msg}`;
  logsEl.prepend(d);
  if(logsEl.childElementCount > 300) logsEl.removeChild(logsEl.lastChild);
}

/* ---------- SYMBOL LOADER ---------- */
/* loads Binance USDT perpetual symbols into the dropdown */
async function loadSymbols(){
  const url = "https://fapi.binance.com/fapi/v1/exchangeInfo";
  try{
    const res = await fetch(url);
    const data = await res.json();
    const list = data.symbols
      .filter(s => s.contractType === "PERPETUAL" && s.status === "TRADING")
      .map(s => s.symbol)
      .sort();
    if(list.length === 0) throw new Error("No symbols");
    symbolSelect.innerHTML = list.map(s => `<option>${s}</option>`).join('');
    // select BTCUSDT by default if present
    const defIdx = list.indexOf('BTCUSDT');
    if(defIdx>=0) symbolSelect.selectedIndex = defIdx;
    symbol = symbolSelect.value;
    log(`Loaded ${list.length} symbols`);
  }catch(e){
    console.warn("Symbol load failed", e);
    // fallback
    symbolSelect.innerHTML = `<option>BTCUSDT</option><option>ETHUSDT</option><option>SOLUSDT</option>`;
    symbol = symbolSelect.value;
    log('Symbol list fallback applied');
  }
}
loadSymbols();

/* ---------- UI SCHEDULER ---------- */
let uiTimer = null;
function scheduleUI(){
  if(uiTimer) return;
  uiTimer = setTimeout(()=>{ uiTimer = null; updateUI(); }, 120);
}

/* ---------- UPDATE UI ---------- */
let lastDisplayedPrice = null;
function updateUI(){
  volsEl.innerText = `${buyVol.toFixed(6)} / ${sellVol.toFixed(6)}`;
  cumlEl.innerText = cumDelta.toFixed(6);
  
  // Update current price at top
  let currentPrice = lastPrice;
  if(!currentPrice) {
    // Fallback to mid price from orderbook
    const bidsByPrice = bids.map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>b[0]-a[0]);
    const asksByPrice = asks.map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>a[0]-b[0]);
    const bestBid = bidsByPrice.length ? bidsByPrice[0][0] : null;
    const bestAsk = asksByPrice.length ? asksByPrice[0][0] : null;
    if(bestBid && bestAsk) {
      currentPrice = (bestBid + bestAsk) / 2;
    }
  }
  
  if(currentPrice) {
    currentPriceEl.innerText = currentPrice.toFixed(4);
    if(lastDisplayedPrice !== null) {
      const change = currentPrice - lastDisplayedPrice;
      const changePct = (change / lastDisplayedPrice) * 100;
      if(change > 0) {
        priceChangeEl.innerText = `+${change.toFixed(4)} (+${changePct.toFixed(2)}%)`;
        priceChangeEl.style.color = '#00ff88';
      } else if(change < 0) {
        priceChangeEl.innerText = `${change.toFixed(4)} (${changePct.toFixed(2)}%)`;
        priceChangeEl.style.color = '#ff7b7b';
      } else {
        priceChangeEl.innerText = '0.0000 (0.00%)';
        priceChangeEl.style.color = 'var(--muted)';
      }
    } else {
      priceChangeEl.innerText = '';
    }
    lastDisplayedPrice = currentPrice;
  } else {
    currentPriceEl.innerText = '—';
    priceChangeEl.innerText = '';
  }
  
  // best bid/ask from L2 snapshot
  const bidsByPrice = bids.map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>b[0]-a[0]);
  const asksByPrice = asks.map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>a[0]-b[0]);
  const bestBid = bidsByPrice.length ? bidsByPrice[0][0] : null;
  const bestAsk = asksByPrice.length ? asksByPrice[0][0] : null;
  
  // Update L2 depth metrics
  document.getElementById('bestBid').innerText = bestBid ? bestBid.toFixed(4) : '-';
  document.getElementById('bestAsk').innerText = bestAsk ? bestAsk.toFixed(4) : '-';
  document.getElementById('bidLevels').innerText = String(bidsByPrice.length);
  document.getElementById('askLevels').innerText = String(asksByPrice.length);
  
  if(bestBid && bestAsk) {
    const spread = bestAsk - bestBid;
    const midPrice = (bestBid + bestAsk) / 2;
    const spreadPct = (spread / midPrice) * 100;
    document.getElementById('spread').innerText = `${spread.toFixed(4)} (${spreadPct.toFixed(3)}%)`;
    document.getElementById('midPrice').innerText = midPrice.toFixed(4);
    
    // Enhanced L2 walls display with % from mid
    buyWallsEl.innerHTML = bidsByPrice.map(it=>{
      const pctFromMid = ((it[0] - midPrice) / midPrice) * 100;
      return `${it[0].toFixed(4)} — ${it[1].toFixed(4)} — ${pctFromMid.toFixed(2)}%`;
    }).join('<br>');
    sellWallsEl.innerHTML = asksByPrice.map(it=>{
      const pctFromMid = ((it[0] - midPrice) / midPrice) * 100;
      return `${it[0].toFixed(4)} — ${it[1].toFixed(4)} — ${pctFromMid.toFixed(2)}%`;
    }).join('<br>');
  } else {
    document.getElementById('spread').innerText = '-';
    document.getElementById('midPrice').innerText = '-';
    buyWallsEl.innerHTML = bidsByPrice.map(it=>`${it[0]} — ${it[1]}`).join('<br>');
    sellWallsEl.innerHTML = asksByPrice.map(it=>`${it[0]} — ${it[1]}`).join('<br>');
  }
  
  // Enhanced wall clusters analysis
  const topB = bidsByPrice.slice().sort((a,b)=>b[1]-a[1]).slice(0,12);
  const topA = asksByPrice.slice().sort((a,b)=>b[1]-a[1]).slice(0,12);
  topBidsEl.innerHTML = topB.map(it=>`${it[0].toFixed(4)} — ${it[1].toFixed(4)}`).join('<br>');
  topAsksEl.innerHTML = topA.map(it=>`${it[0].toFixed(4)} — ${it[1].toFixed(4)}`).join('<br>');
  
  // Wall cluster metrics
  const wallSize = parseFloat(wallSizeInput.value) || WALL_SIZE_DEFAULT;
  const buyClusterCount = topB.filter(it=>it[1] > wallSize).length;
  const sellClusterCount = topA.filter(it=>it[1] > wallSize).length;
  buyClusterEl.innerText = String(buyClusterCount);
  sellClusterEl.innerText = String(sellClusterCount);
  
  // Total wall quantities
  const totalBuyQty = bidsByPrice.reduce((sum, it) => sum + it[1], 0);
  const totalSellQty = asksByPrice.reduce((sum, it) => sum + it[1], 0);
  document.getElementById('totalBuyWallQty').innerText = totalBuyQty.toFixed(2);
  document.getElementById('totalSellWallQty').innerText = totalSellQty.toFixed(2);
  
  // Largest walls
  const largestBuy = topB.length > 0 ? topB[0] : null;
  const largestSell = topA.length > 0 ? topA[0] : null;
  document.getElementById('largestBuyWall').innerText = largestBuy ? `${largestBuy[0].toFixed(4)} (${largestBuy[1].toFixed(2)})` : '—';
  document.getElementById('largestSellWall').innerText = largestSell ? `${largestSell[0].toFixed(4)} (${largestSell[1].toFixed(2)})` : '—';
  
  // strength
  const ratio = buyVol / Math.max(sellVol, 1e-9);
  if(ratio > 1.6) strengthEl.innerText = 'BUYERS DOMINANT';
  else if(ratio > 1.2) strengthEl.innerText = 'Buyers Strong';
  else if(ratio < 0.4) strengthEl.innerText = 'SELLERS DOMINANT';
  else if(ratio < 0.6) strengthEl.innerText = 'Sellers Strong';
  else strengthEl.innerText = 'Balanced';
  
  // Update signals continuously (check delta flip, momentum, etc.)
  if(lastPrice !== null) {
    const deltaSide = cumDelta > 0 ? 'buy' : 'sell';
    const deltaFlipToBuy = lastDeltaSide === 'sell' && deltaSide === 'buy';
    const deltaFlipToSell = lastDeltaSide === 'buy' && deltaSide === 'sell';
    const momentum = Math.abs(cumDelta) > 25;
    const wallShift = wallShiftDetected();
    const sweepHigh = (lastHigh !== null && lastPrice > lastHigh);
    const sweepLow = (lastLow !== null && lastPrice < lastLow);
    // Reaction: price moved faster than previous move (simplified check)
    const reaction = (lastPrice2 !== null && lastPrice !== null) ? 
      (Math.abs(lastPrice - lastPrice2) > 0.0001) : false;
    
    currentSignals = {
      sweep: (sweepHigh || sweepLow) ? 'YES' : 'NO',
      deltaFlip: (deltaFlipToBuy || deltaFlipToSell) ? 'YES' : 'NO',
      momentum: momentum ? 'YES' : 'NO',
      wallShift: wallShift ? 'YES' : 'NO',
      reaction: reaction ? 'YES' : 'NO',
      sweepLow: sweepLow ? 'YES' : 'NO'
    };
    updateSignalDisplays(currentSignals);
  }
}

/* ---------- CLEAR STATE ---------- */
function clearAll(){
  buyVol = 0; sellVol = 0; cumDelta = 0;
  recentTrades = [];
  bids = []; asks = [];
  lastPrice = lastPrice2 = null;
  lastHigh = lastLow = null;
  lastDeltaSide = null;
  lastDisplayedPrice = null;
  agg1m = []; agg5m = [];
  swingPanelContainer.innerHTML = '';
  logsEl.innerHTML = '';
  // Reset signals
  currentSignals = {
    sweep: 'NO',
    deltaFlip: 'NO',
    momentum: 'NO',
    wallShift: 'NO',
    reaction: 'NO',
    sweepLow: 'NO',
    reactionSpeed: 'NO'
  };
  updateSignalDisplays(currentSignals);
  updateUI();
  log('State cleared');
}

/* ---------- AGGREGATION ---------- */
function aggregateConfluence(price, qty, side, ts){
  const minute = Math.floor(ts / 60000) * 60000;
  const fiveMinute = Math.floor(ts / (5*60000)) * (5*60000);
  // 1m bucket
  let b1 = (agg1m.length && agg1m[agg1m.length-1].tStart === minute) ? agg1m[agg1m.length-1] : null;
  if(!b1){
    b1 = { tStart: minute, buyVol:0, sellVol:0, delta:0, price: price };
    agg1m.push(b1);
    if(agg1m.length > AGG_MAX) agg1m.shift();
  }
  // always update latest price for bucket
  b1.price = price;
  if(side === 'buy'){ b1.buyVol += qty; b1.delta += qty; } else { b1.sellVol += qty; b1.delta -= qty; }
  // 5m
  let b5 = (agg5m.length && agg5m[agg5m.length-1].tStart === fiveMinute) ? agg5m[agg5m.length-1] : null;
  if(!b5){
    b5 = { tStart: fiveMinute, buyVol:0, sellVol:0, delta:0, price: price };
    agg5m.push(b5);
    if(agg5m.length > AGG_MAX) agg5m.shift();
  }
  b5.price = price;
  if(side === 'buy'){ b5.buyVol += qty; b5.delta += qty; } else { b5.sellVol += qty; b5.delta -= qty; }
}

/* ---------- DIVERGENCE DETECTION ---------- */
/* Using last 4 1-minute buckets: check price vs delta divergence */
function detectDeltaDivergence(){
  if(agg1m.length === 0) {
    return `No data yet`;
  }
  
  if(agg1m.length < 4) {
    // Show partial information if we have some buckets
    const available = agg1m.slice(-agg1m.length);
    if(available.length >= 2) {
      const first = available[0];
      const last = available[available.length - 1];
      const priceChange = ((last.price - first.price) / first.price) * 100;
      const deltaChange = last.delta - first.delta;
      return `Collecting data (${agg1m.length}/4 buckets)<br><small style="opacity:0.7">Current: Price ${priceChange >= 0 ? '↑' : '↓'}${Math.abs(priceChange).toFixed(2)}%, Delta ${deltaChange >= 0 ? '↑' : '↓'}${Math.abs(deltaChange).toFixed(2)}</small>`;
    }
    return `Waiting for data (${agg1m.length}/4 buckets)`;
  }
  
  const last4 = agg1m.slice(-4);
  // compare first vs last
  const p0 = last4[0].price;
  const p3 = last4[3].price;
  const d0 = last4[0].delta;
  const d3 = last4[3].delta;
  // guard
  if(typeof p0 !== 'number' || typeof p3 !== 'number' || typeof d0 !== 'number' || typeof d3 !== 'number') {
    return 'Invalid data';
  }
  const priceChange = ((p3 - p0) / p0) * 100;
  const deltaChange = d3 - d0;
  const priceUp = p3 > p0;
  const deltaDown = d3 < d0;
  const priceDown = p3 < p0;
  const deltaUp = d3 > d0;
  
  let result = '';
  if(priceUp && deltaDown) {
    result = `BEAR divergence: Price ↑${priceChange.toFixed(2)}% but Delta ↓${deltaChange.toFixed(2)}`;
  } else if(priceDown && deltaUp) {
    result = `BULL divergence: Price ↓${Math.abs(priceChange).toFixed(2)}% but Delta ↑${deltaChange.toFixed(2)}`;
  } else {
    result = `No divergence: Price ${priceChange >= 0 ? '↑' : '↓'}${Math.abs(priceChange).toFixed(2)}%, Delta ${deltaChange >= 0 ? '↑' : '↓'}${Math.abs(deltaChange).toFixed(2)}`;
  }
  
  // Add bucket details
  result += `<br><small style="opacity:0.7">Buckets: P0=${p0.toFixed(2)} Δ0=${d0.toFixed(2)} → P3=${p3.toFixed(2)} Δ3=${d3.toFixed(2)}</small>`;
  
  return result;
}

/* ---------- UPDATE SIGNAL DISPLAYS ---------- */
function updateSignalDisplays(signals){
  // Update 5 key signals
  signalSweepEl.innerText = signals.sweep || 'NO';
  signalSweepEl.className = signals.sweep === 'YES' ? 'signal-yes' : 'signal-no';
  
  signalDeltaFlipEl.innerText = signals.deltaFlip || 'NO';
  signalDeltaFlipEl.className = signals.deltaFlip === 'YES' ? 'signal-yes' : 'signal-no';
  
  signalMomentumEl.innerText = signals.momentum || 'NO';
  signalMomentumEl.className = signals.momentum === 'YES' ? 'signal-yes' : 'signal-no';
  
  signalWallShiftEl.innerText = signals.wallShift || 'NO';
  signalWallShiftEl.className = signals.wallShift === 'YES' ? 'signal-yes' : 'signal-no';
  
  signalReactionEl.innerText = signals.reaction || 'NO';
  signalReactionEl.className = signals.reaction === 'YES' ? 'signal-yes' : 'signal-no';
  
  // Update quick indicators
  indicatorLiquiditySweepEl.innerText = signals.sweep || 'NO';
  indicatorLiquiditySweepEl.className = signals.sweep === 'YES' ? 'signal-yes' : 'signal-no';
  
  indicatorDeltaFlipEl.innerText = signals.deltaFlip || 'NO';
  indicatorDeltaFlipEl.className = signals.deltaFlip === 'YES' ? 'signal-yes' : 'signal-no';
  
  indicatorReactionEl.innerText = signals.reaction || 'NO';
  indicatorReactionEl.className = signals.reaction === 'YES' ? 'signal-yes' : 'signal-no';
}

/* ---------- SWING ENGINE ---------- */
/* rateSwing returns star string */
function rateSwing(st){
  const flags = [st.sweep, st.deltaFlip, st.momentum, st.wallShift, st.reaction];
  // flags are 'YES' / 'NO' -> count YES
  const n = flags.filter(x=>x==='YES').length;
  const filled = '★'.repeat(n);
  const empty = '☆'.repeat(5 - n);
  return `<span class="stars">${filled}${empty}</span>`;
}
function showSwingPanel(type, price, st){
  const color = type === 'HIGH' ? '#ff4444' : '#00ff88';
  const title = type === 'HIGH' ? 'SWING HIGH' : 'SWING LOW';
  const stars = rateSwing(st);
  const html = `
    <div class="alertBox ${type==='HIGH' ? 'swing-high' : 'swing-low'}">
      <strong style="color:${color};font-size:15px">${title} @ ${price}</strong><br><br>
      • Liquidity Sweep: <b>${st.sweep}</b><br>
      • Delta Flip: <b>${st.deltaFlip}</b><br>
      • Momentum: <b>${st.momentum}</b><br>
      • Wall Shift: <b>${st.wallShift}</b><br>
      • Reaction Speed: <b>${st.reaction}</b><br>
      <hr>
      <b>Swing Rating: ${stars}</b>
    </div>
  `;
  swingPanelContainer.innerHTML = html + swingPanelContainer.innerHTML;
  log(`${title} @ ${price} | ${stars.replace(/<.*?>/g,'')}`);
}

/* simplified wallShift detection (uses last orderbook snapshot) */
function wallShiftDetected(){
  if(!lastOrderbookSnapshot) return false;
  try{
    const oldTopBuy = lastOrderbookSnapshot.bids[0]?.[1] ?? 0;
    const oldTopSell = lastOrderbookSnapshot.asks[0]?.[1] ?? 0;
    const newTopBuy = bids[0]?.[1] ?? 0;
    const newTopSell = asks[0]?.[1] ?? 0;
    return (newTopBuy > oldTopBuy * 1.4) || (newTopSell > oldTopSell * 1.4);
  }catch(e){ return false; }
}

/* core detectSwing called on each trade */
function detectSwing(price){
  const deltaSide = cumDelta > 0 ? 'buy' : 'sell';
  const deltaFlipToBuy = lastDeltaSide === 'sell' && deltaSide === 'buy';
  const deltaFlipToSell = lastDeltaSide === 'buy' && deltaSide === 'sell';
  // sweep: price breaks previous lastHigh/lastLow
  const sweepHigh = (lastHigh !== null && price > lastHigh);
  const sweepLow  = (lastLow !== null && price < lastLow);
  const momentum = Math.abs(cumDelta) > 25; // tunable threshold
  const wallShift = wallShiftDetected();
  const reaction = (lastPrice2 !== null) ? (Math.abs(price - lastPrice2) > Math.abs(lastPrice - lastPrice2) * 1.5) : false;
  const swingStatus = {
    sweep: (sweepHigh || sweepLow) ? 'YES' : 'NO',
    deltaFlip: (deltaFlipToBuy || deltaFlipToSell) ? 'YES' : 'NO',
    momentum: momentum ? 'YES' : 'NO',
    wallShift: wallShift ? 'YES' : 'NO',
    reaction: reaction ? 'YES' : 'NO',
    sweepLow: sweepLow ? 'YES' : 'NO'
  };
  
  // Always update current signals and display
  currentSignals = swingStatus;
  updateSignalDisplays(currentSignals);
  
  // fire when mandatory combo meets:
  if(sweepHigh && deltaFlipToSell){
    showSwingPanel('HIGH', price, swingStatus);
  }
  if(sweepLow && deltaFlipToBuy){
    showSwingPanel('LOW', price, swingStatus);
  }
  // update lastDeltaSide and swing memory
  lastDeltaSide = deltaSide;
  if(lastHigh === null || price > lastHigh) lastHigh = price;
  if(lastLow === null || price < lastLow) lastLow = price;
}

/* ---------- HANDLERS: depth & trade ---------- */
function handleDepthPayload(payload){
  // Binance depth uses arrays of [price, qty]
  if(payload.b) bids = payload.b.slice();
  if(payload.a) asks = payload.a.slice();
  lastOrderbookSnapshot = { bids: bids.slice(), asks: asks.slice() };
  scheduleUI();
}
function handleTradePayload(t){
  // t.p price, t.q qty, t.m maker flag, t.ts optional timestamp (for historical replay)
  const price = f(t.p);
  const qty = f(t.q);
  const isMaker = !!t.m;
  const side = isMaker ? 'sell' : 'buy';
  const ts = t.ts || now(); // Use provided timestamp for historical replay, otherwise current time
  // record
  recentTrades.unshift({ price, qty, side, ts });
  if(recentTrades.length > 2000) recentTrades.pop();
  // update vol/delta
  if(side === 'buy'){ buyVol += qty; cumDelta += qty; }
  else { sellVol += qty; cumDelta -= qty; }
  // update price history
  lastPrice2 = lastPrice;
  lastPrice = price;
  // aggregate
  aggregateConfluence(price, qty, side, ts);
  // detect swing
  detectSwing(price);
  // update sweep UI (sweep rebuilt in detectSwing logic)
  const sweepText = (lastHigh === null && lastLow === null) ? '—' : `Sweep: High=${(lastPrice>lastHigh? 'YES':'NO')} | Low=${(lastPrice<lastLow? 'YES':'NO')}`;
  sweepInfoEl.innerText = sweepText;
  scheduleUI();
}

/* ---------- CONNECT / WS ---------- */
connectBtn.addEventListener('click', () => {
  if(running) return;
  symbol = symbolSelect.value.trim();
  useMode = modeSelect.value || 'both';
  if(!symbol){ alert('Select a symbol'); return; }
  clearAll(); // clear before replay
  const stream = `${symbol.toLowerCase()}@trade/${symbol.toLowerCase()}@depth20@100ms`;
  const url = `wss://fstream.binance.com/stream?streams=${stream}`;
  ws = new WebSocket(url);
  statusEl.innerText = 'Connecting...';
  ws.onopen = () => {
    statusEl.innerText = 'Connected';
    running = true;
    connectBtn.style.display = 'none';
    disconnectBtn.style.display = 'inline-block';
    log('WS open');
    // Historical replay: load last 20 minutes of aggTrades, then engine will be initialized
    loadHistoricalTrades(symbol).then(() => {
      log("Historical baseline built. Now live data will be accurate instantly.");
    });
    startCalibration();
    // start deep polling if needed
    if(useMode === 'rest' || useMode === 'both'){
      startDeepPolling();
    }
  };
  ws.onmessage = ev => {
    try{
      const msg = JSON.parse(ev.data);
      const payload = msg.data || msg;
      if(!payload) return;
      // trades
      if(payload.e === 'trade' || payload.e === 'aggTrade' || payload.p){
        const trade = payload.e ? payload : payload.data || payload;
        handleTradePayload(trade);
      }
      // depth
      if(payload.b || payload.a){
        const depth = payload;
        handleDepthPayload(depth);
      }
      // sometimes payload is nested in 'data' again
      if(Array.isArray(payload) && payload.length){
        // ignore
      }
    }catch(e){
      console.warn('ws parse', e);
    }
  };
  ws.onerror = e => {
    statusEl.innerText = 'WS error';
    log('WS error');
    console.error(e);
  };
  ws.onclose = () => {
    statusEl.innerText = 'Disconnected';
    running = false;
    connectBtn.style.display = 'inline-block';
    disconnectBtn.style.display = 'none';
    stopCalibration();
    log('WS closed');
  };
});

disconnectBtn.addEventListener('click', () => {
  if(ws) ws.close();
  ws = null;
  running = false;
  statusEl.innerText = 'Disconnected';
  connectBtn.style.display = 'inline-block';
  disconnectBtn.style.display = 'none';
  stopCalibration();
  stopDeepPolling();
});

/* ---------- DOWNLOAD CSV ---------- */
downloadBtn.addEventListener('click', () => {
  const rows = ['side,price,qty'];
  bids.forEach(b => rows.push(`bid,${b[0]},${b[1]}`));
  asks.forEach(a => rows.push(`ask,${a[0]},${a[1]}`));
  const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `${symbol || 'snapshot'}_l2.csv`; a.click();
  URL.revokeObjectURL(url);
});

/* ---------- CLEAR ---------- */
clearBtn.addEventListener('click', clearAll);

/* ---------- CALIBRATION ---------- */
let calibrationStartedAt = null;
let calibrationInterval = null;
function startCalibration(){
  calibrationStartedAt = now();
  calibEl.innerText = `Calibrating…`;
  if(calibrationInterval) clearInterval(calibrationInterval);
  calibrationInterval = setInterval(()=>{
    if(!calibrationStartedAt){ clearInterval(calibrationInterval); return; }
    const elapsed = Math.floor((now() - calibrationStartedAt) / 1000);
    const remaining = CALIBRATION_SECONDS - elapsed;
    if(remaining <= 0){
      calibEl.innerText = 'READY ✓';
      clearInterval(calibrationInterval);
      log('Calibration complete — engine ready');
    } else {
      calibEl.innerText = `Calibrating… ${remaining}s`;
    }
  }, 800);
}
function stopCalibration(){
  calibrationStartedAt = null;
  calibEl.innerText = 'Not running';
  if(calibrationInterval) clearInterval(calibrationInterval);
}

/* ---------- HISTORICAL REPLAY (last 20 minutes) ---------- */
async function loadHistoricalTrades(sym){
  try {
    const endTime = Date.now();
    const startTime = endTime - (20 * 60 * 1000); // last 20 minutes
    log(`Fetching 20 min historical trades for ${sym}...`);
    // Binance aggTrades supports startTime,endTime but may return up to 1000 items per request.
    // We'll fetch in a loop if needed, but usually 20 minutes fits in 1000 aggTrades for many symbols.
    const url = `https://fapi.binance.com/fapi/v1/aggTrades?symbol=${encodeURIComponent(sym)}&startTime=${startTime}&endTime=${endTime}&limit=1000`;
    const res = await fetch(url);
    const data = await res.json();
    if(!Array.isArray(data)){
      log("Historical load failed (not array)");
      return;
    }
    log(`Loaded ${data.length} historical trades — Replaying...`);
    // Replay each trade with actual timestamps for proper aggregation
    for(const t of data){
      // Use actual trade timestamp (T is in milliseconds)
      const tradeTs = t.T || t.t || Date.now();
      const trade = { p: t.p, q: t.q, m: t.m, ts: tradeTs };
      handleTradePayload(trade);
    }
    // Force UI update after replay
    updateUI();
    log("Historical replay complete — Engine is fully initialized!");
  } catch (e) {
    console.error(e);
    log("Historical replay failed");
  }
}

/* ---------- INITIALIZE ---------- */
clearAll();
updateUI();
log('Dashboard ready. Click Connect.');

// lightweight UI updater
setInterval(()=>{ scheduleUI(); }, 1000);

/* ---------- Switch symbol mode updates ---------- */
modeSelect.addEventListener('change', (e)=>{ useMode = e.target.value; });
</script>

<!-- ============================
     Part 3/3 — Deep Snapshot + Far-Wall Radar
     - Uses REST depth=1000 snapshots (fapi.binance.com)
     - Combines WS top20 (live) + REST deep (far walls)
     - Finds 5 large buys below price and 5 large sells above price
     ============================ -->
<script>
/* ---------- STATE for deep walls ---------- */
let deepBids = []; // full deep snapshot from REST: [[price, qty], ...]
let deepAsks = [];
let deepFetchTimer = null;
let farRadarTimer = null;
let deepFetchIntervalMs = 15000; // fetch REST deep snapshot every 15s
let farRadarRefreshMs = 1000;    // recompute far walls every 1s
let lastDeepFetchAt = 0;

/* ---------- UI refs (radar) ---------- */
const farBuysEl = document.getElementById('farBuys');
const farSellsEl = document.getElementById('farSells');
const radarDistPctInput = document.getElementById('radarDistPct');
const radarMinQtyInput = document.getElementById('radarMinQty');

/* ---------- HELPERS ---------- */
function safeParseNumber(v){
  const n = parseFloat(v);
  return Number.isFinite(n) ? n : 0;
}
function formatPrice(p){
  return (typeof p === 'number') ? p.toFixed(4) : String(p);
}

/* ---------- DEEP SNAPSHOT FETCH ---------- */
async function fetchDeepSnapshot(sym){
  if(!sym) return;
  const url = `https://fapi.binance.com/fapi/v1/depth?symbol=${encodeURIComponent(sym)}&limit=1000`;
  try{
    lastDeepFetchAt = Date.now();
    const res = await fetch(url);
    if(!res.ok) throw new Error('HTTP ' + res.status);
    const data = await res.json();
    // Binance depth API returns 'bids' and 'asks' arrays (or 'b' and 'a' in some formats)
    // Each entry is [price, quantity] as strings
    const bidsData = data.bids || data.b || [];
    const asksData = data.asks || data.a || [];
    
    if(bidsData.length === 0 && asksData.length === 0){
      log(`Deep snapshot warning: Empty response for ${sym}. Response keys: ${Object.keys(data).join(', ')}`);
      console.log('Full API response:', data);
    }
    
    deepBids = bidsData.map(x => [safeParseNumber(x[0]), safeParseNumber(x[1])]);
    deepAsks = asksData.map(x => [safeParseNumber(x[0]), safeParseNumber(x[1])]);
    // keep them sorted (bids desc, asks asc)
    deepBids.sort((a,b)=>b[0]-a[0]);
    deepAsks.sort((a,b)=>a[0]-b[0]);
    log(`Deep snapshot fetched: bids=${deepBids.length} asks=${deepAsks.length}`);
    // immediately compute far walls after fetching
    computeFarWalls();
  }catch(err){
    console.warn('deep snapshot failed', err);
    log(`Deep snapshot fetch failed: ${err.message}`);
  }
}

/* ---------- COMPUTE FAR WALLS ---------- */
function computeFarWalls(){
  try {
    // determine current price to measure distance threshold
    let currentPrice = lastPrice;
    if(!currentPrice){
      // fallback to top-of-book best mid
      const bidsByPrice = bids.map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>b[0]-a[0]);
      const asksByPrice = asks.map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>a[0]-b[0]);
      const bestBid = bidsByPrice.length > 0 ? bidsByPrice[0][0] : null;
      const bestAsk = asksByPrice.length > 0 ? asksByPrice[0][0] : null;
      if(bestBid && bestAsk) currentPrice = (bestBid + bestAsk) / 2;
      else currentPrice = null;
    }
    
    if(!currentPrice){
      farBuysEl.innerHTML = '<span style="opacity:0.6">Waiting for price data...</span>';
      farSellsEl.innerHTML = '<span style="opacity:0.6">Waiting for price data...</span>';
      return;
    }
    
    if(!deepBids.length && !deepAsks.length){
      farBuysEl.innerHTML = '<span style="opacity:0.6">Waiting for deep snapshot...</span>';
      farSellsEl.innerHTML = '<span style="opacity:0.6">Waiting for deep snapshot...</span>';
      return;
    }

    // read filter values
    const distPct = Math.max(0, safeParseNumber(radarDistPctInput.value));
    const minQty = Math.max(0, safeParseNumber(radarMinQtyInput.value));

    // builds buys: bids with price <= currentPrice * (1 - distPct/100)
    const buyThresholdPrice = currentPrice * (1 - distPct/100);
    const sellsThresholdPrice = currentPrice * (1 + distPct/100);

    // find buys below threshold and qty >= minQty (nearest first)
    let candidateBuys = deepBids
      .filter(([p,q]) => p <= buyThresholdPrice && q >= minQty)
      .sort((a,b)=>b[0]-a[0]) // nearest below = highest price first
      .slice(0, 50);

    // If no buys found with filters, fallback to top 5 largest buys below price (ignore distance filter)
    let buysSelected = candidateBuys.slice(0,5);
    if(buysSelected.length === 0 && deepBids.length > 0) {
      buysSelected = deepBids
        .filter(([p,q]) => p < currentPrice && q >= (minQty * 0.5)) // Relax qty filter slightly
        .sort((a,b)=>b[1]-a[1]) // Sort by quantity (largest first)
        .slice(0, 5)
        .sort((a,b)=>b[0]-a[0]); // Then sort by price (nearest first)
    }
    // Final fallback: just top 5 largest bids below price
    if(buysSelected.length === 0 && deepBids.length > 0) {
      buysSelected = deepBids
        .filter(([p,q]) => p < currentPrice)
        .sort((a,b)=>b[1]-a[1]) // Sort by quantity
        .slice(0, 5)
        .sort((a,b)=>b[0]-a[0]); // Then by price
    }

    // find sells above threshold and qty >= minQty (nearest first)
    let candidateSells = deepAsks
      .filter(([p,q]) => p >= sellsThresholdPrice && q >= minQty)
      .sort((a,b)=>a[0]-b[0]) // nearest above = lowest price first
      .slice(0,50);

    let sellsSelected = candidateSells.slice(0,5);
    // If no sells found with filters, fallback to top 5 largest sells above price
    if(sellsSelected.length === 0 && deepAsks.length > 0) {
      sellsSelected = deepAsks
        .filter(([p,q]) => p > currentPrice && q >= (minQty * 0.5)) // Relax qty filter slightly
        .sort((a,b)=>b[1]-a[1]) // Sort by quantity (largest first)
        .slice(0, 5)
        .sort((a,b)=>a[0]-b[0]); // Then sort by price (nearest first)
    }
    // Final fallback: just top 5 largest asks above price
    if(sellsSelected.length === 0 && deepAsks.length > 0) {
      sellsSelected = deepAsks
        .filter(([p,q]) => p > currentPrice)
        .sort((a,b)=>b[1]-a[1]) // Sort by quantity
        .slice(0, 5)
        .sort((a,b)=>a[0]-b[0]); // Then by price
    }

    // Render buys - always show something if data exists
    if(buysSelected.length === 0) {
      farBuysEl.innerHTML = '<span style="opacity:0.6">No buy walls available</span>';
    } else {
      const rows = buysSelected.map(([p,q])=>{
        const pctDist = ((currentPrice - p) / currentPrice) * 100;
        return `<div style="margin-bottom:4px"><b>${formatPrice(p)}</b> — ${q.toFixed(4)}  <span style="opacity:0.65">(${pctDist.toFixed(2)}% below)</span></div>`;
      });
      farBuysEl.innerHTML = rows.join('');
    }

    // Render sells - always show something if data exists
    if(sellsSelected.length === 0) {
      farSellsEl.innerHTML = '<span style="opacity:0.6">No sell walls available</span>';
    } else {
      const rows = sellsSelected.map(([p,q])=>{
        const pctDist = ((p - currentPrice) / currentPrice) * 100;
        return `<div style="margin-bottom:4px"><b>${formatPrice(p)}</b> — ${q.toFixed(4)}  <span style="opacity:0.65">(${pctDist.toFixed(2)}% above)</span></div>`;
      });
      farSellsEl.innerHTML = rows.join('');
    }
  } catch(e) {
    console.error('computeFarWalls error:', e);
    farBuysEl.innerHTML = '<span style="opacity:0.6">Error computing far walls</span>';
    farSellsEl.innerHTML = '<span style="opacity:0.6">Error computing far walls</span>';
  }
}

/* ---------- SCHEDULE DEEP FETCH & RADAR ---------- */
function startDeepPolling(){
  // stop any existing timers
  if(deepFetchTimer) clearInterval(deepFetchTimer);
  if(farRadarTimer) clearInterval(farRadarTimer);

  // immediate fetch then periodic
  fetchDeepSnapshot(symbol).catch(()=>{});
  deepFetchTimer = setInterval(()=>{ if(symbol) fetchDeepSnapshot(symbol); }, deepFetchIntervalMs);

  // compute far walls often (UI update)
  computeFarWalls(); // immediate
  farRadarTimer = setInterval(()=>{ computeFarWalls(); }, farRadarRefreshMs);
}

function stopDeepPolling(){
  if(deepFetchTimer) clearInterval(deepFetchTimer);
  if(farRadarTimer) clearInterval(farRadarTimer);
  deepFetchTimer = null;
  farRadarTimer = null;
}

/* ---------- WIRING: start deep polling when connected & symbol changes ---------- */
symbolSelect.addEventListener('change', (e)=>{
  symbol = e.target.value;
  // if in connected state, refetch deep snapshot
  if(running && (useMode === 'rest' || useMode === 'both')){
    fetchDeepSnapshot(symbol);
  }
});

// Update far walls when filter inputs change
radarDistPctInput.addEventListener('input', ()=>{
  if(running) computeFarWalls();
});
radarMinQtyInput.addEventListener('input', ()=>{
  if(running) computeFarWalls();
});

/* ---------- Safety: stop polling when page hidden ---------- */
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden){
    // pause heavy REST fetches
    if(deepFetchTimer) clearInterval(deepFetchTimer);
  } else {
    // resume
    if(useMode === 'rest' || useMode === 'both'){
      if(!deepFetchTimer) deepFetchTimer = setInterval(()=>{ if(symbol) fetchDeepSnapshot(symbol); }, deepFetchIntervalMs);
    }
  }
});

/* ---------- Initial quick deep fetch attempt (if symbol loaded) ---------- */
setTimeout(()=>{ if(symbolSelect.value) { symbol = symbolSelect.value; fetchDeepSnapshot(symbol); } }, 1200);

/* ---------- Optional: UI manual refresh control (not displayed) ---------- */
function manualDeepRefresh(){
  if(symbol) fetchDeepSnapshot(symbol);
}

/* ---------- Final: ensure computeFarWalls uses latest data by scheduling regular UI update ---------- */
// This is handled by farRadarTimer in startDeepPolling, but we also update it in the main UI updater
setInterval(()=>{ 
  try{ 
    if(running && (useMode === 'rest' || useMode === 'both')) {
      computeFarWalls(); 
    }
  }catch(e){
    console.warn('Far walls update error:', e);
  } 
}, 3000);
</script>
</body>
</html>

